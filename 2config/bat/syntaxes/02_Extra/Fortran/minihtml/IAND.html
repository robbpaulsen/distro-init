<code>IAND</code> — Bitwise logical and

<h3>Description</h3>
Bitwise logical <code>AND</code>.

     <br>

<h3>Syntax</h3>
<code>RESULT = IAND(I, J)</code>

     <br>

<h3>Arguments</h3>

     <p><table summary=""><tbody><tr align="left"><td valign="top" width="15%"><var>I</var> </td><td valign="top" width="70%">The type shall be <code>INTEGER</code>. 
<br></td></tr><tr align="left"><td valign="top" width="15%"><var>J</var> </td><td valign="top" width="70%">The type shall be <code>INTEGER</code>, of the same
kind as <var>I</var>.  (As a GNU extension, different kinds are also
permitted.)
     <br></td></tr></tbody></table>

     <br></p>

<h3>Return value</h3>
The return type is <code>INTEGER</code>, of the same kind as the
arguments.  (If the argument kinds differ, it is of the same kind as
the larger argument.)

     <br>

<h3>Example</h3>

     <code class="smallexample" syntax="Packages/Fortran/grammars/FortranModern.sublime-syntax">
<br>PROGRAM test_iand
<br>  INTEGER :: a, b
<br>  DATA a / Z'F' /, b / Z'3' /
<br>  WRITE (*,*) IAND(a, b)
<br>END PROGRAM</code>
     <br>

<h3>Standard</h3>
Fortran 95 and later

     <br>

<h3>Class</h3>
Elemental function

     <br>

<h3>See also</h3>
<a href="IOR.html#IOR">IOR</a>, <a href="IEOR.html#IEOR">IEOR</a>, <a href="IBITS.html#IBITS">IBITS</a>, <a href="IBSET.html#IBSET">IBSET</a>, <a href="IBCLR.html#IBCLR">IBCLR</a>, <a href="NOT.html#NOT">NOT</a>

   