<code>C_F_POINTER</code> — Convert C into Fortran pointer

<h3>Description</h3>
<code>C_F_POINTER(CPTR, FPTR[, SHAPE])</code> assigns the target of the C pointer
<var>CPTR</var> to the Fortran pointer <var>FPTR</var> and specifies its shape.

     <br>

<h3>Syntax</h3>
<code>CALL C_F_POINTER(CPTR, FPTR[, SHAPE])</code>

     <br>

<h3>Arguments</h3>

     <p><table summary=""><tbody><tr align="left"><td valign="top" width="15%"><var>CPTR</var>  </td><td valign="top" width="70%">scalar of the type <code>C_PTR</code>. It is
<code>INTENT(IN)</code>. 
<br></td></tr><tr align="left"><td valign="top" width="15%"><var>FPTR</var>  </td><td valign="top" width="70%">pointer interoperable with <var>cptr</var>. It is
<code>INTENT(OUT)</code>. 
<br></td></tr><tr align="left"><td valign="top" width="15%"><var>SHAPE</var> </td><td valign="top" width="70%">(Optional) Rank-one array of type <code>INTEGER</code>
with <code>INTENT(IN)</code>. It shall be present
if and only if <var>fptr</var> is an array. The size
must be equal to the rank of <var>fptr</var>.
     <br></td></tr></tbody></table>

     <br></p>

<h3>Example</h3>

     <code class="smallexample" syntax="Packages/Fortran/grammars/FortranModern.sublime-syntax">
<br>program main
<br>  use iso_c_binding
<br>  implicit none
<br>  interface
<br>    subroutine my_routine(p) bind(c,name='myC_func')
<br>      import :: c_ptr
<br>      type(c_ptr), intent(out) :: p
<br>    end subroutine
<br>  end interface
<br>  type(c_ptr) :: cptr
<br>  real,pointer :: a(:)
<br>  call my_routine(cptr)
<br>  call c_f_pointer(cptr, a, [12])
<br>end program main</code>
     <br>

<h3>Standard</h3>
Fortran 2003 and later

     <br>

<h3>Class</h3>
Subroutine

     <br>

<h3>See also</h3>
<a href="C_005fLOC.html#C_005fLOC">C_LOC</a>, <a href="C_005fF_005fPROCPOINTER.html#C_005fF_005fPROCPOINTER">C_F_PROCPOINTER</a>
